using System;
using System.Collections.Generic;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Text;
using Jil;
using nylium.Extensions;
using nylium.Utilities;

namespace nylium.Generators {
    
    public class BlockGenerator {

        private const string outputDirectory = "blocks";

        /// <summary>
        /// 0 - block name
        /// 1 - block id
        /// 2 - min state
        /// 3 - max state
        /// 4 - default state
        /// 5 - state get
        /// 6 - state (property) set
        /// 7 - properties
        /// 8 - properties as constructor arguments
        /// 9 - property setters (constructor)
        /// 10 - protocol id
        /// </summary>
        private const string blockTemplate = @"// FILE AUTOGENERATED. DO NOT MODIFY
using System;

namespace nylium.Core.Block.Blocks {{

    [Block(""{1}"", {10}, {2}, {3}, {4})]
    public class Block{0} : BlockBase {{

        public override ushort State {{
            get {{
{5}                return DefaultState;
            }}

            set {{
{6}            }}
        }}

{7}
        public Block{0}() {{
            State = DefaultState;
        }}

        public Block{0}(ushort state) : base(state) {{
            if(state < MinimumState || state > MaximumState) {{
                throw new ArgumentOutOfRangeException(""state"");
            }}

            State = state;
        }}

        public Block{0}({8}) {{
{9}        }}
    }}
}}";
        
        private const string blockTemplate0 = @"// FILE AUTOGENERATED. DO NOT MODIFY
using System;

namespace nylium.Core.Block.Blocks {{

    [Block(""{1}"", {10}, {2}, {3}, {4})]
    public class Block{0} : BlockBase {{

        public override ushort State {{
            get {{
{5}                return DefaultState;
            }}

            set {{
{6}            }}
        }}

{7}
        public Block{0}() {{
            State = DefaultState;
        }}

        public Block{0}(ushort state) {{
            if(state < MinimumState || state > MaximumState) {{
                throw new ArgumentOutOfRangeException(""state"");
            }}

            State = state;
        }}
    }}
}}";

        private const string ifTemplate = @"                if({0}) {{
                    {1}
                }}

";

        private const string propertyTemplate = "        public {0} {1} {{ get; set; }} = ";
        private const string parameterTemplate = "{0} {1}, ";
        private const string setterTemplate = "            {0} = {1};\n";

        public static void Run(string[] args) {
            if(!Directory.Exists(outputDirectory)) {
                Directory.CreateDirectory(outputDirectory);
            }

            Dictionary<string, string> generatedBlocks = new();
            ushort maxStateId = 0;

            MemoryStream compressedStream = RMSManager.Get().GetStream(Properties.Resources.blocks);
            GZipStream zipStream = new(compressedStream, CompressionMode.Decompress);
            MemoryStream resultStream = RMSManager.Get().GetStream();
            
            zipStream.CopyTo(resultStream);

            dynamic blocks = JSON.DeserializeDynamic(Encoding.UTF8.GetString(resultStream.ToArray()));

            compressedStream = RMSManager.Get().GetStream(Properties.Resources.blockstates);
            zipStream = new(compressedStream, CompressionMode.Decompress); 
            resultStream = RMSManager.Get().GetStream();
            
            zipStream.CopyTo(resultStream);
            
            dynamic blockstates = JSON.DeserializeDynamic(Encoding.UTF8.GetString(resultStream.ToArray()));

            int bitsPerBlock = 0;

            foreach(dynamic block in blocks) {
                string namedId = block.Key;

                // air is unneeded
                if(namedId == "minecraft:air") continue;
                
                Console.WriteLine("Generating " + namedId);

                dynamic block1 = blockstates[0].blocks.block[namedId.Replace("minecraft:", "")];

                if(block1 == null) {
                    Console.WriteLine("eh?? " + namedId);
                    continue;
                }

                bool propertiesDone = false;
                
                int protocolId = block1.numeric_id;
                int minState = block1.min_state_id;
                int maxState = block1.max_state_id;
                int defaultState = 0;

                if(maxState > maxStateId) {
                    maxStateId = (ushort) maxState;
                }

                Dictionary<string, string> properties = new();
                StringBuilder stateGet = new();
                StringBuilder stateSet = new();

                StringBuilder parameters = new();
                StringBuilder setters = new();

                bool hasProperties = false;

                foreach(dynamic state in block.Value.states) {
                    StringBuilder checks = new();

                    if(state.properties != null) {
                        hasProperties = true;
                        
                        foreach(dynamic property in state.properties) {
                            checks.Append(((string) property.Key).ToPascalCase());
                            checks.Append(" == ");

                            if(property.Value == "true" || property.Value == "false") {
                                checks.Append((string) property.Value);

                                if(!propertiesDone) {
                                    properties.Add((string) property.Key, string.Format(propertyTemplate, "bool",
                                        ((string) property.Key).ToPascalCase()));

                                    parameters.Append(string.Format(parameterTemplate, "bool", property.Key));
                                    setters.Append(string.Format(setterTemplate, ((string) property.Key).ToPascalCase(),
                                        property.Key));
                                }
                            } else if(((string) property.Value).All(char.IsDigit)) {
                                checks.Append((string) property.Value);

                                if(!propertiesDone) {
                                    properties.Add((string) property.Key, string.Format(propertyTemplate, "int",
                                        ((string) property.Key).ToPascalCase()));

                                    parameters.Append(string.Format(parameterTemplate, "int", property.Key));
                                    setters.Append(string.Format(setterTemplate, ((string) property.Key).ToPascalCase(),
                                        property.Key));
                                }
                            } else if(decimal.TryParse((string) property.Value, out _)) {
                                checks.Append((string) property.Value);

                                if(!propertiesDone) {
                                    properties.Add((string) property.Key, string.Format(propertyTemplate, "float",
                                        ((string) property.Key).ToPascalCase()));

                                    parameters.Append(string.Format(parameterTemplate, "float", property.Key));
                                    setters.Append(string.Format(setterTemplate, ((string) property.Key).ToPascalCase(),
                                        property.Key));
                                }
                            } else {
                                //checks.Append('"');
                                checks.Append(property.Value);
                                //checks.Append('"');

                                if(!propertiesDone) {
                                    properties.Add((string) property.Key, string.Format(propertyTemplate, "string",
                                        ((string) property.Key).ToPascalCase()));

                                    parameters.Append(string.Format(parameterTemplate, "string", property.Key));
                                    setters.Append(string.Format(setterTemplate, ((string) property.Key).ToPascalCase(),
                                        property.Key));
                                }
                            }

                            checks.Append(" && ");
                        }
                    }

                    if(state.@default != null) {
                        defaultState = state.id;
                        
                        foreach(string key in properties.Keys.ToList()) {
                            if(state.properties[key] == "true" || state.properties[key] == "false") {
                                properties[key] += (string) state.properties[key] + ";";
                            } else if(((string) state.properties[key]).All(char.IsDigit)) {
                                properties[key] += (string) state.properties[key] + ";";
                            } else if(decimal.TryParse((string) state.properties[key], out _)) {
                                properties[key] += (string) state.properties[key] + ";";
                            } else {
                                properties[key] += "\"" + (string) state.properties[key] + "\";";
                            }
                        }
                    }

                    if(!propertiesDone) {
                        propertiesDone = true;
                    }

                    if(hasProperties) {
                        string checks1 = checks.ToString();
                        checks1 = checks1.Substring(0, checks1.Length - 4);

                        stateGet.Append(string.Format(ifTemplate, checks1, "return " + state.id + ";"));

                        checks1 = checks1.Replace("==", "=");
                        checks1 = checks1.Replace(" && ", ";\n");
                        checks1 += ";";

                        stateSet.Append(string.Format(ifTemplate, "value == " + state.id, checks1));
                    }
                }

                StringBuilder propertiesStr = new();

                foreach(KeyValuePair<string, string> entry in properties) {
                    propertiesStr.Append(entry.Value);
                    propertiesStr.Append('\n');
                }

                if(hasProperties) parameters.Length -= 2;

                string b = string.Format(hasProperties ? blockTemplate : blockTemplate0, namedId.Replace("minecraft:", "").ToPascalCase(),
                    namedId, minState, maxState, defaultState, stateGet, stateSet, propertiesStr, parameters, setters, protocolId);

                generatedBlocks.Add("Block" + namedId.Replace("minecraft:", "").ToPascalCase() + ".cs", b);
            }
            
            Console.WriteLine("Saving blocks...");
            
            foreach(KeyValuePair<string, string> generated in generatedBlocks) {
                File.WriteAllText(Path.Combine(outputDirectory, generated.Key),
                    generated.Value);
            }
            
            bitsPerBlock = (int) Math.Ceiling(Math.Log2(maxStateId));
            Console.WriteLine("Bits per block: " + bitsPerBlock);
        }
    }
}