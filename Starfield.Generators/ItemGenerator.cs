using System;
using System.Collections.Generic;
using System.IO;
using System.IO.Compression;
using System.Text;
using Jil;
using Starfield.Extensions;
using Starfield.Utilities;

namespace Starfield.Generators {

    public class ItemGenerator {

        private const string outputDirectory = "items";

        /// <summary>
        /// 0 - class name
        /// 1 - item id
        /// 2 - protocol id
        /// 3 - max stack size
        /// </summary>
        private const string itemTemplate = @"// FILE AUTOGENERATED. DO NOT MODIFY
namespace Starfield.Core.Item.Items {{

    [Item(""{1}"", {2}, {3})]
    public class Item{0} : BlockItem {{ }}
}}";
        
        /// <summary>
        /// 0 - class name
        /// 1 - item id
        /// 2 - protocol id
        /// 3 - max stack size
        /// 4 - block protocol id
        /// </summary>
        private const string blockTemplate = @"// FILE AUTOGENERATED. DO NOT MODIFY
namespace Starfield.Core.Item.Items {{

    [Item(""{1}"", {2}, {3}, {4})]
    public class Item{0} : BlockItem {{ }}
}}";

        /// <summary>
        /// 0 - class name
        /// 1 - item id
        /// 2 - protocol id
        /// 3 - max stack size
        /// 4 - nutrition
        /// 5 - saturation modifier
        /// 6 - can always eat
        /// </summary>
        private const string foodTemplate = @"// FILE AUTOGENERATED. DO NOT MODIFY
namespace Starfield.Core.Item.Items {{

    [Item(""{1}"", {2}, {3}, {4}, {5}f, {6})]
    public class Item{0} : FoodItem {{ }}
}}";
        
        /// <summary>
        /// 0 - class name
        /// 1 - item id
        /// 2 - protocol id
        /// 3 - max stack size
        /// 4 - uses
        /// 5 - speed
        /// 6 - attack damage
        /// 7 - attack damage bonus
        /// </summary>
        private const string swordTemplate = @"// FILE AUTOGENERATED. DO NOT MODIFY
namespace Starfield.Core.Item.Items {{

    [Item(""{1}"", {2}, {3}, {4}, {5}f, {6}f, {7}f)]
    public class Item{0} : ToolItem {{ }}
}}";
        
        /// <summary>
        /// 0 - class name
        /// 1 - item id
        /// 2 - protocol id
        /// 3 - max stack size
        /// 4 - uses
        /// 5 - speed
        /// 6 - attack damage
        /// 7 - attack damage bonus
        /// 8 - diggable blocks
        /// </summary>
        private const string pickaxeTemplate = @"// FILE AUTOGENERATED. DO NOT MODIFY
namespace Starfield.Core.Item.Items {{

    [Item(""{1}"", {2}, {3}, {4}, {5}f, {6}f, {7}f, {8})]
    public class Item{0} : PickaxeItem {{ }}
}}";
        
        /// <summary>
        /// 0 - class name
        /// 1 - item id
        /// 2 - protocol id
        /// 3 - max stack size
        /// 4 - uses
        /// 5 - speed
        /// 6 - attack damage
        /// 7 - attack damage bonus
        /// 8 - diggable blocks
        /// 9 - flattenable block states
        /// </summary>
        private const string shovelTemplate = @"// FILE AUTOGENERATED. DO NOT MODIFY
namespace Starfield.Core.Item.Items {{

    [Item(""{1}"", {2}, {3}, {4}, {5}f, {6}f, {7}f, {8}, false)]
    public class Item{0} : ShovelItem {{ }}
}}";
        
        /// <summary>
        /// 0 - class name
        /// 1 - item id
        /// 2 - protocol id
        /// 3 - max stack size
        /// 4 - uses
        /// 5 - speed
        /// 6 - attack damage
        /// 7 - attack damage bonus
        /// 8 - diggable blocks
        /// 9 - effective materials
        /// 10 - strippable blocks
        /// </summary>
        private const string axeTemplate = @"// FILE AUTOGENERATED. DO NOT MODIFY
namespace Starfield.Core.Item.Items {{

    [Item(""{1}"", {2}, {3}, {4}, {5}f, {6}f, {7}f, {8}, {9})]
    public class Item{0} : AxeItem {{ }}
}}";
        
        /// <summary>
        /// 0 - class name
        /// 1 - item id
        /// 2 - protocol id
        /// 3 - max stack size
        /// 4 - uses
        /// 5 - speed
        /// 6 - attack damage
        /// 7 - attack damage bonus
        /// 8 - diggable blocks
        /// 9 - tillable block states
        /// </summary>
        private const string hoeTemplate = @"// FILE AUTOGENERATED. DO NOT MODIFY
namespace Starfield.Core.Item.Items {{

    [Item(""{1}"", {2}, {3}, {4}, {5}f, {6}f, {7}f, {8}, true)]
    public class Item{0} : ShovelItem {{ }}
}}";

        public static void Run(string[] args) {
            if(!Directory.Exists(outputDirectory)) {
                Directory.CreateDirectory(outputDirectory);
            }

            Dictionary<string, string> generatedItems = new();

            MemoryStream compressedStream = RMSManager.Get().GetStream(Properties.Resources.items);
            GZipStream zipStream = new(compressedStream, CompressionMode.Decompress);
            MemoryStream resultStream = RMSManager.Get().GetStream();
            
            zipStream.CopyTo(resultStream);

            dynamic items = JSON.DeserializeDynamic(Encoding.UTF8.GetString(resultStream.ToArray()));

            foreach(dynamic it in items) {
                string id = it.Key;
                dynamic item = it.Value;
                
                int protocolId = item.id;
                int maxStackSize = item.max_stack_size;

                string clsName = id.Replace("minecraft:", "").ToPascalCase();
                
                // air is unneeded
                if(id == "minecraft:air") continue;
                
                Console.WriteLine("Generating " + id);
                string i;
                
                if(item.ContainsKey("block")) {
                    i = string.Format(blockTemplate, clsName, id, protocolId, maxStackSize, item.block);
                } else if(item.ContainsKey("food_properties")) {
                    i = string.Format(foodTemplate, clsName, id, protocolId, maxStackSize,
                        item.food_properties.nutrition, item.food_properties.saturation_modifier,
                        item.food_properties.can_always_eat);
                } else if(id.Contains("sword")) {
                    i = string.Format(swordTemplate, clsName, id, protocolId, maxStackSize,
                        item.uses, item.speed, item.attack_damage, item.attack_damage_bonus);
                } else if(id.Contains("pickaxe")) {
                    StringBuilder arr = new("new int[] { ");

                    foreach(int block in item.diggable_blocks) {
                        arr.Append(block);
                        arr.Append(", ");
                    }

                    arr.Length -= 2;
                    arr.Append(" }");
                    
                    i = string.Format(pickaxeTemplate, clsName, id, protocolId, maxStackSize,
                        item.uses, item.speed, item.attack_damage, item.attack_damage_bonus, arr.ToString());
                } else if(id.Contains("axe")) {
                    StringBuilder arr = new("new int[] { ");

                    foreach(int block in item.diggable_blocks) {
                        arr.Append(block);
                        arr.Append(", ");
                    }

                    arr.Length -= 2;
                    arr.Append(" }");
                    
                    StringBuilder arr0 = new("new string[] { ");

                    foreach(string material in item.effective_materials) {
                        arr0.Append('"');
                        arr0.Append(material);
                        arr0.Append('"');
                        arr0.Append(", ");
                    }

                    arr0.Length -= 2;
                    arr0.Append(" }");

                    i = string.Format(axeTemplate, clsName, id, protocolId, maxStackSize,
                        item.uses, item.speed, item.attack_damage, item.attack_damage_bonus, arr.ToString(),
                        arr0.ToString(),
                        "null"); // TODO how are we supposed to pass a dictionary to an attribute?
                } else if(id.Contains("hoe")) {
                    StringBuilder arr = new("new int[] { ");

                    foreach(int block in item.diggable_blocks) {
                        arr.Append(block);
                        arr.Append(", ");
                    }

                    arr.Length -= 2;
                    arr.Append(" }");
                    
                    i = string.Format(hoeTemplate, clsName, id, protocolId, maxStackSize,
                        item.uses, item.speed, item.attack_damage, item.attack_damage_bonus, arr.ToString(), "null");
                } else if(id.Contains("shovel")) {
                    StringBuilder arr = new("new int[] { ");

                    foreach(int block in item.diggable_blocks) {
                        arr.Append(block);
                        arr.Append(", ");
                    }

                    arr.Length -= 2;
                    arr.Append(" }");
                    
                    i = string.Format(shovelTemplate, clsName, id, protocolId, maxStackSize,
                        item.uses, item.speed, item.attack_damage, item.attack_damage_bonus, arr.ToString(), "null");
                } else {
                    i = string.Format(itemTemplate, clsName, id, protocolId, maxStackSize);
                }
                
                generatedItems.Add($"Item{clsName}.cs", i);
            }
            
            Console.WriteLine("Saving blocks...");

            foreach(KeyValuePair<string, string> entry in generatedItems) {
                File.WriteAllText(Path.Combine(outputDirectory, entry.Key), entry.Value);
            }
        }
    }
}